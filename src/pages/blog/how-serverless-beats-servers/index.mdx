---
title: "How serverless beats servers"
description: ""
published: 2020-01-28
redirect_from:
  - /blog/how-serverless-beats-servers/swizec/9311
categories: "Back End, Technical"
content_upgrade: ServerlessHandbook
hero: ./img/techletter.app-screenshot-1580225198153.png
---

import { ContentUpgrades } from "@swizec/gatsby-theme-course-platform"

You're building an app. It needs to store some data. What do you do?

Easy.

Put it in local storage.

[Click through for source](<https://carbon.now.sh/?bg=rgba(255,255,255,1)&t=seti&l=javascript&ds=true&wc=true&wa=true&pv=48px&ph=32px&ln=false&code=localStorage.setItem(%0A%09'item'%2C%20%0A%09JSON.stringify(%7B%22property1%22%3A%202%2C%20%22property2%22%3A%203%7D)%0A)>)

You can read `'item'` next time users visit your app. Yay.

Unless they're on a different computer. Or browser. Or need to share between users.

**Time to add a backend. How hard can it be?**

Start a RubyOnRails project, create a model for your data, add routes for reading and writing, add some glue code in your controller, install the JBuilder gem, write a JSON view, create a migration file, run the Postgres database locally, start your Rails app and you're ready to test.

Then you go to AWS, create a new EC2 instance, pick from a billion Linux distributions, set up an HTTP server like Nginx, run your Rails app, add a cronjob to restart the app when it dies, buy a new domain on Namecheap, set up its DNS servers, wait a few hours, point the domain to your server ...

... and you still need the production database.

You now have a virtual server and database running 24/7. Unless they die.

You're in charge of keeping them up, maintaining configuration, waking up at 3am if something goes wrong, and paying for every second of every day _even if nobody uses your app_.

Just to store some data.

![kill_me giphy](./img/media-jSxK33dwEMbkY-giphy.gif)

Yes, services like Heroku make it easier. Docker gives you pre-configured Linux machines, and Kubernetes does whatever Kubernetes does. Helps keep your servers alive? Maybe improve deployments?

Did I mention you still have to host your webapp somewhere?

You'll need a static file server, some CDN setup, optimize JavaScript builds for production ... you want your webapp to be fast. Can't have it hitting Rails for every little CSS file.

It's a lot of work.

Weeks of engineering time at my day job. üòÖ

There's a better way, my friend. Serverless for the backend, JAMStack for the frontend.

`<ContentUpgrades.ServerlessHandbook />`

## Serverless for the backend

The simplest serverless backends look just like functions.

[Click through for source](<https://carbon.now.sh/?bg=rgba(255,255,255,1)&t=seti&l=typescript&ds=true&wc=true&wa=true&pv=48px&ph=32px&ln=false&code=export%20const%20handler%20%3D%20async%20(event%3A%20APIGatewayEvent)%20%3D%3E%20%7B%0A%09return%20%7B%0A%09%09statusCode%3A%20200%2C%0A%09%09body%3A%20%22Hello%20%F0%9F%91%8B%22%0A%09%7D%3B%0A%7D%3B>)

That's all it takes. That's a server üòç

I like to use TypeScript for the backend so I make fewer mistakes. That's where the `APIGatewayEvent` part comes from.

We [talked about GraphQL](https://serverlessreact.dev/#how-graphql-blows-rest-out-of-the-water) last week, so let's see what it takes to build a basic GraphQL API with serverless.

You need just 2 files:

- an infrastructure definition
- a lambda function that creates your GraphQL server

### infrastructure as code

[Click through for source](<https://carbon.now.sh/?bg=rgba(255,255,255,1)&t=seti&l=yaml&ds=true&wc=true&wa=true&pv=48px&ph=32px&ln=false&code=service%3A%20smol-graphql%0A%0A%23%20Define%20provider%20and%20runtime%0Aprovider%3A%0A%20%20%20%20name%3A%20aws%0A%20%20%20%20runtime%3A%20nodejs12.x%0A%20%20%20%20stage%3A%20dev%0A%20%20%20%20%23%20these%20are%20env%20vars%0A%20%20%20%20environment%3A%0A%20%20%20%20%20%20%20%20ITEM_TABLE%3A%20%24%7Bself%3Aservice%7D-items-%24%7Bself%3Aprovider.stage%7D%0A%20%20%20%20%23%20AWS%20is%20strict%20about%20permissions%20%3A)%0A%20%20%20%20iamRoleStatements%3A%0A%20%20%20%20%20%20%20%20-%20Effect%3A%20Allow%0A%20%20%20%20%20%20%20%20%20%20Action%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20-%20dynamodb%3AQuery%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20-%20dynamodb%3AScan%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20-%20dynamodb%3AGetItem%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20-%20dynamodb%3APutItem%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20-%20dynamodb%3AUpdateItem%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20-%20dynamodb%3ADeleteItem%0A%20%20%20%20%20%20%20%20%20%20Resource%3A%20%22arn%3Aaws%3Adynamodb%3A%24%7Bopt%3Aregion%2C%20self%3Aprovider.region%7D%3A*%3Atable%2F%24%7Bself%3Aprovider.environment.ITEM_TABLE%7D%22%0A%20%20%20%20%20%20%20%20%20%20%0A%23%20define%20a%20%2Fgraphql%20function%0Afunctions%3A%0A%20%20%20%20graphql%3A%0A%20%20%20%20%20%20%20%20handler%3A%20dist%2Fgraphql.handler%0A%20%20%20%20%20%20%20%20events%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20-%20http%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20path%3A%20graphql%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20method%3A%20GET%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20cors%3A%20true%0A%20%20%20%20%20%20%20%20%20%20%20%20-%20http%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20path%3A%20graphql%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20method%3A%20POST%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20cors%3A%20true%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%23%20create%20a%20DynamoDB%20table%0Aresources%3A%0A%20%20%20%20Resources%3A%0A%20%20%20%20%20%20%20%20ItemsTable%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20Type%3A%20%22AWS%3A%3ADynamoDB%3A%3ATable%22%0A%20%20%20%20%20%20%20%20%20%20%20%20Properties%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20AttributeDefinitions%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20-%20AttributeName%3A%20itemId%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20AttributeType%3A%20S%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20KeySchema%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20-%20AttributeName%3A%20itemId%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20KeyType%3A%20HASH%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20ProvisionedThroughput%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20ReadCapacityUnits%3A%201%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20WriteCapacityUnits%3A%201%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20TableName%3A%20%24%7Bself%3Aprovider.environment.ITEM_TABLE%7D>)

This might look scary, but imagine doing it by hand. Eeeevery time you want to make a small change.

It's your whole infrastructure. Defines your runtime environment, API endpoints, even creates a database using DynamoDB. And it hooks everything up on its own.

Your infrastructure becomes code.

That way you always know what's running in production. Every branch of your project can use a different