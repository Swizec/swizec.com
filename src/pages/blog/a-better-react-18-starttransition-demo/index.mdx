---
title: "A better React 18 startTransition demo"
description: "Demoing startTransition is hard. Modern computers are too fast 😅 – Dan Abramov, a React core team member, helped me get it right. Here's what I learned"
published: 2021-06-16
categories: "Technical, React, Frontend"
hero: ./img/screenshot-1623860768995.png
---

Demoing startTransition is hard. Modern computers are too fast 😅

The [demo I sent you last week](https://swizec.com/blog/trying-out-react-18-alpha/#lets-try-it-out) doesn't work. It's an aberration. A fluke of dev mode.

Dan Abramov, React core team, messaged me on Twitter and said _"Yo dude, every render takes less than 1ms, startTransition and time slicing don't even have time to kick in"_

💩

So I built a better demo on stream. Later Dan tweaked it to correctly show off the new `startTransition` feature. I got it wrong. It's subtle.

https://www.youtube.com/watch?v=6WRRf2ldixY

You can [try the final demo here](https://react-fractals-git-react-18-swizec.vercel.app/)

[![React 18 startTransition demo with lag indicator](./img/React-18-startTransition-demo-with-lag-indicatorja3id2.gif)](https://react-fractals-git-react-18-swizec.vercel.app/)

I [built the fractal](https://swizec.com/blog/dancing-tree-fractal-with-react/) to stress test React back in 2016, added form controls this week. Dan added the lag indicator, slow mode, faded transitioning state, and fixed my use of `startTransition`.

You can [see the code on GitHub](https://github.com/Swizec/react-fractals/pull/15)

## Why it's slow

https://twitter.com/Swizec/status/1404917798527111168

The [pythagoras tree](<https://en.wikipedia.org/wiki/Pythagoras_tree_(fractal)>) is a fractal. A deeply nested data structure that brings any rendering framework to its knees. Drawing to the DOM is the least of your worries.

The left sets nesting level. At 20 (max) your computer will slow down for sure. My 2020 top-spec MacBook sure did 😅

![Growing a fractal tree](./img/Growing-a-fractal-tree3fj237.gif)

Each layer spawns 2 branches. Every update touches every branch. That's `2^20-1 = 1,048,575` updates for every change in lean angle.

That's what makes this a great stress test :)

- user code: calculates all that data
- framework code: propagates the updates
- browser code: redraws the DOM nodes

You'll get more speed from WebGL or Canvas. Not much you can do about the nested tree with 1,000,000 elements. Math is math.

> in a real app your tree is dominated by user logic, not by raw div updates

Modern computers are fast though, you can [say screw it to web performance](https://swizec.com/blog/screw-web-performance-just-wait-a-little/) 😛

![2016 vs. 2020](./img/2016-vs-2020hfi56h.gif)

## How Dan debugged my demo

Dan looked at my demo and said _"Hm that doesn't look like it's working"_. But how did he verify? I asked.

![Profiler view when startTransition didn't work](./img/Profiler-view-when-startTransition-didnt-work5c2j6a.png)

> I used Performance tab and pressed record. What was supposed to happen is that each input update should be very fast and non-blocking. But instead of many small updates I saw a few large ones.

An old Webpack polyfill got in the way.

Here's what your profiler is supposed to show without `startTransition`.

![Working code, startTransition disabled](./img/Working-code-startTransition-disabledi2c1a3.png)

> 1.  urgent updates should exclude large trees thanks to memo
> 2.  transitions work in small chunks

Enable `startTransition` and you'll see those big tasks collapse into tiny updates.

![startTransition enabled](./img/startTransition-enabledec927e.png)

Quick way to test you're leveraging `startTransition`. Don't get fooled like I did 😅

And remember: realistic timing happens in production.

## A startTransition gotcha

`startTransition` lets you mark calculations and updates as not urgent. React performs them later.

You can use this for expensive data transformation, large computations, or complex rendering. Anything goes.

```javascript
startTransition(() => {
  // do slow work
})
```

Sounds easy and it's easy to get wrong. Make it ineffective 🥲

### Use separate state for non-urgent updates

My first attempt looked kinda like this:

```javascript
const [treeLean, setTreeLean] = useState(0)

function changeTreeLean(event) {
    const value = Number(event.target.value);

    // update visuals
    if (enableStartTransition) {
        React.startTransition(() => {
            setTreeLean(value);
        });
    } else {
        setTreeLean(value);
    }
}

// ...
<input type="range" value={treeLean} onChange={changeTreeLean} />

<Pythagoras lean={treeLean} ... />
```

Change input, call `changeTreeLean` as the event handler. Tell React to update state inside a transition.

And everything's laggy 🤔

Because _both components depend on the same state_ ...

You have to split that state.

Either by creating slider sub-components with internal urgent state, or the dirty way:

```javascript
const [treeLean, setTreeLean] = useState(0)
const [treeLeanInput, setTreeLeanInput] = useState(0)

function changeTreeLean(event) {
    const value = Number(event.target.value);
    setTreeLeanInput(value)

    // update visuals
    if (enableStartTransition) {
        React.startTransition(() => {
            setTreeLean(value);
        });
    } else {
        setTreeLean(value);
    }
}

// ...
<input type="range" value={treeLeanInput} onChange={changeTreeLean} />

<Pythagoras lean={treeLean} ... />
```

Now the input field and the tree can update separately. `startTransition` makes a big difference.

[![React 18 startTransition demo with lag indicator](./img/React-18-startTransition-demo-with-lag-indicatora2g643.gif)](https://react-fractals-git-react-18-swizec.vercel.app/)

### Use React.memo

> Adds `memo` around Pythagoras that's necessary for an urgent update to actually skip rendering the tree.

```javascript
const Pythagoras = React.memo(() => {
  // same component code as usual
})
```

Wrap expensive components in `React.memo` to give `startTransition` a chance to kick in. React needs to know it's safe to split the render step.

## Show transitioning state

I thought this was neat. You can show the user that a redraw is happening.

```javascript
const [isLeaning, startLeaning] = useTransition()

// ...

function changeTreeLean(event) {
    const value = Number(event.target.value);
    setTreeLeanInput(value); // update input

    // update visuals
    if (enableStartTransition) {
        startLeaning(() => {
            setTreeLean(value);
        });
    } else {
        setTreeLean(value);
    }
}

// ...

<svg style={ opacity: isLeaning ? 0.7 : 1 }
```

The `useTransition` hook lets you access transition state. _"Are we done yet?"_

Instead of calling `startTransition`, you call the function returned from the hook – `startLeaning`. Then you can access done-ness with the boolean – `isLeaning`.

You'll [notice the tree fades out](https://react-fractals-git-react-18-swizec.vercel.app/) on big re-renders.

## My biggest surprise?

Take React code from 2016, update to React 18 alpha, touch nothing else ... and it works. No bugs 😱

Had to update `react-scripts` from 0.7 to 4.0 though. An old Webpack polyfill was killing `startTransition`.

That's why we torture alpha versions my friend. For bugs like that ✌️

Cheers,<br/>
~Swizec

PS: [React For Dataviz](https://reactfordataviz.com) is my course on pushing React to the max and fun stuff like this​. I think it's getting a new module or two when React 18 comes out :)
