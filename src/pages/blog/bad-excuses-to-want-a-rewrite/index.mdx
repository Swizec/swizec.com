---
title: "Bad excuses to want a rewrite"
description: "Here's a sneak peek at a new book I'm writing about Refactoring and Rewriting. It's with a publisher so I might get in trouble for sharing this, but it's a first draft ... they own the final version üòõ"
published: 2022-04-28
hero: ./img/screenshot-1651160978901.png
---

_Here's a sneak peek at a new book I'm writing about Refactoring and Rewriting. It's with a publisher so I might get in trouble for sharing this, but it's a first draft ... they own the final version_ üòõ

> This code is terrible. We should rewrite.

Literally every new engineer on every team.

1. Does it work?
2. Has the context changed?

Okay then leave it alone. It‚Äôs fine.

Every one of those little things you see that looks weird is a bug fix. A lesson learned. An edge case found. A painful memory enshrined in code.

You start with a simple function that responds to an event and updates the database.

```javascript
async function handleEvent(event) {
  const item = await readFromDB(event.item.id)

  if (event.newState) {
    await item.save({
      status: event.newState,
    })
    await notifyUserOfChange(item)
  }

  return `Status updated to ${event.newState}`
}
```

Pretend this function is called from a queue or notification service. You get an `{event}` that happened on `{event.item}` and update the `{item.status}` field in the database. After saving, you send a notification to the owner of this item. Like an email that says _‚ÄùYour item is out for delivery‚Äù_

One day the notification service sends an event with no item. Due to a weird bug in `{readFromDB}`, your database locked up for 5 minutes and caused a huge outage.

Both the notification service and the database are outside your control. Best you can do is to check before reading.

```javascript
async function handleEvent(event) {
  if (!event.item) {
    throw new Error(`Missing event.item`)
  }

  const item = await readFromDB(event.item.id)

  if (event.newState) {
    await item.save({
      status: event.newState,
    })
    await notifyUserOfChange(item)
  }

  return `Status updated to ${event.newState}`
}
```

You now throw an error when there‚Äôs no item in the event. The error handling framework will handle logging and sending the right response status to the notification service.

A few days pass and you notice something strange in the logs. There‚Äôs a lot of database errors when calling `{item.save}`. ü§® You can barely find the logs you care about through the stack traces and convoluted error messages.

After some digging you find that the notification service is pinging you for items that don‚Äôt exist. You can‚Äôt fix that even if you wanted to. You can add another check to your code though.

```javascript
async function handleEvent(event) {
  if (!event.item) {
    throw new Error(`Missing event.item`)
  }

  const item = await readFromDB(event.item.id)

  if (!item) {
    throw new Error(`Item not found`)
  }

  if (event.newState) {
    await item.save({
      status: event.newState,
    })
    await notifyUserOfChange(item)
  }

  return `Status updated to ${event.newState}`
}
```

Great. You make sure the `{item}` was found in your database before trying to do anything else. Still...