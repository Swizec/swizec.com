---
title: "Don't Worry; It's a Compiler Bug"
description: ""
published: 2015-12-29
redirect_from:
  - /blog/dont-worry-its-a-compiler-bug/swizec/6764
categories: "ECMAScript, Front End, JavaScript, Source-to-source compiler, Technical"
hero: ../../../defaultHero.jpg
---

When I was a kid writing DOS games in Pascal, I would often get stuck on a problem. After I had exhausted all my knowledge and all the help files, I would conclude, without a doubt, that something was wrong with my machine.

There wasn't.

When I was a teenager making subpar websites in PHP, I would often get stuck on a problem. After I had exhausted all my knowledge and all the help files and all the internet I could find, I would conclude, again without a doubt, that PHP was being shitty and running my code wrong.

It wasn't.

> "It's never the compiler's fault."
>
> ~ Smart People

This is hyperbole, of course. System bugs _do_ happen. But not often.

A programmer can go his or her entire career without hitting a compiler, operating system, or hardware bug. In fact, studies in the late 1970's showed that 95% of bugs are caused by programmers. Of the rest, 2% fall on system software, 2% on other software, and 1% on hardware. [\[1\]](http://blog.codinghorror.com/the-first-rule-of-programming-its-always-your-fault/)

Usually, it's your fault.

After being a mess for a **long** time, PHP only recently started getting good. Ruby didn't even have a well-defined grammar until 2013 [\[2\]](http://programmingisterrible.com/post/42432568185/how-to-parse-ruby). 

These days though, compilers are built by people who aren't exactly Ritchie, Stroustrup, Knuth, Wirth and the like. Don't get me wrong, compiler developers are still great guys. It just feels like modern core-tech code is missing the discipline of days gone by.

It's an even bigger mess now that everyone is [transpiling](http://en.wikipedia.org/wiki/Source-to-source_compiler "Source-to-source compiler") code from ES5 to ES6. In theory, this shouldn't be a big deal. You take code from one version of the language, and you turn it into another version. Just a bit of back-porting and some syntax sugar converting.

In practice, it means there's another compiler in your stack; two, if you're using a dependency management system like Webpack as well.

## So I got hit by a compiler bug ...

Three weeks ago, I realized _why_ Our App(tm) didn't work on Safari. Some of my code was using ES6's `{Map}`, which Chrome supports, but Safari does not. I thought [Babel](https://babeljs.io/) would deal with that out of the box, but I was wrong.

Something to do with `{Map}` being a semantic feature and Babel needing to use polyfills that implement `{Map}` in pure ES5. 

The upgrade path is simple: remove old packages, install new packages, tweak some configs. 

In the new system, you need 6 packages to do syntax transpiling _and_ semantic polyfills; like this:

```son
// dependencies in package.json
    "babel-core": "^6.3.15",
    "babel-loader": "^6.2.0",
    "babel-plugin-transform-runtime": "^6.3.13",
    "babel-polyfill": "^6.3.14",
    "babel-preset-es2015": "^6.3.13",
    "babel-runtime": "^6.3.13",
```

That's a lot of packages to install for one piece of Stuff, but hey, I'm sure that won't be painful to update in two months at all …

You also need to add a `babel-polyfill` entry to your Webpack config and enable the `transform-runtime` and `es2015` plugins. 

```javascript
entry: {
            // ...
            babel_polyfill: 'babel-polyfill'
},
loaders: [
            {
                test: /\.js$/,
                include: [
                    path.resolve(__dirname, "app/assets/javascripts")
                ],
                exclude: /node_modules/,
                loader: 'babel-loader',
                query: {
                    plugins: ['transform-runtime'],
                    presets: ['es2015']
                }
            },
```

After jumping through the stack trace, we found the error deep inside the bowels of some sort of polyfill for `{typeof}`. 

In this case, the error was caused by `{typeof}` circularly trying to use itself in every instance our code used it in. 

## Great. Now what?

So what do you do when you have to deploy tonight, the compiler is messing up your code, and [a ticket for the bug](https://phabricator.babeljs.io/T6644) has been open for three weeks?

All it took to make the codebase ready for deploy was to change all instances of `{typeof}` into Lodash's type helpers — things like `_.isObject` and `_.isFunction`.

As luck would have it, we'd only used `{typeof}` in five places. My change only caused one bug that got through code review and into production!

Great success! \\o/

Babel's `{typeof}` bug has since been fixed, by the way. Although the last comment on its discussion thread says _"Uhh ... I still get this when using babel-plugin-transform-runtime"_. Guess we're waiting for the version dependency to propagate through the world.

## So what went wrong, actually?

Here's the real sequence of events that lead to the only time I found a compiler bug in 19 years of programming.

1.  Failure to test code in multiple browsers

    - I thought we had polyfills; we didn't.

2.  Lack of automated tests

    - I relied on coworkers to "click around" to find problems.

3.  Merging bad things to master branch and not having a good rollback strategy

    - If you break the master, you block the production deploy

4.  Haphazardly updating core parts of the build stack

5.  Babel throwing old versions out the window on upgrades

6.  Using bleeding-edge technologies

All in all, this was a very avoidable problem. But now I know, when you're on the bleeding edge, it totally _can_ be a compiler bug.