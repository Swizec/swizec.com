---
title: "Using scopes for elegant JAMStack permissions"
description: ""
published: 2020-06-15
redirect_from:
  - /blog/using-scopes-for-elegant-jamstack-permissions/swizec/9431
categories: "Front End, Technical"
hero: ./img/techletter.app-screenshot-1592236049540.png
---

About a month ago I wrote about [Adding granular role-based access to your JAMStack app](https://swizec.com/blog/add-granular-rolebased-access-to-your-jamstack-app/). That worked okay.

Use something like [useAuth](https://github.com/Swizec/useAuth) to authenticate users, add some roles, then check those roles in your app. Often at the main `<Layout>` level.

You get an app that sometimes asks for additional permissions.

![app screenshot showing additional permissions](./img/5eSMcCw.gif)

But this approach had 2 warts:

1.  Lots of people mentioned that _scopes_ in practice scale better than roles
2.  You needed this gnarly code somewhere in your app

![Screenshot of gnarly code](./img/techletter.app-screenshot-1592236049540.png)

![gif image](./img/media-y7kvOYLzas6Ag-giphy-downsized-medium.gif)

## Scopes bring more elegance

Wanted to use this approach for my [React for Dataviz](https://reactfordataviz.com) course, which has 3 tiers on top of free stuff, and my head began to spin. No way this was gonna work. üòÖ

I set out to find a better way:

![Another screenshot of code](./img/techletter.app-screenshot-1592236049300.png)

And I found one! Scopes.

A scope is no different than a role ‚Äì a string attached to the user. The _semantics_ of scopes are different though.

Instead of answering _"Who is this user?"_ a scope answers _"What can this user do?"_. Small difference, big impact.

And when you move permission checking to the router-level, the result is quite elegant. I think.

Haven't tried it with NextJS, with Gatsby you'd do something like this üëá

### 1. wrap the root of your tree

Permission-checking happens as high up in your component tree as possible. For Gatsby that's the `wrapPageElement` method. I use the same method for `gatsby-ssr` and `gatsby-browser`.

![Code example for wrapping root](./img/techletter.app-screenshot-1592236047097.png)

Wrap everything in useAuth's `<AuthProvider>` then render the `<MyRouter>` component making sure to pass the element and all props.

### 2. a simple router

Next you need a router to map paths to components. Gatsby comes with [reach/router](https://reach.tech/router) built-in so that seems like a good choice.

Unfortunately I couldn't get it to work reliably. Kept matching incorrect routes. The integration isn't as tight as I hoped.

![Image screenshot](./img/techletter.app-screenshot-1592236047596.png)

![Image screenshot](./img/techletter.app-screenshot-1592236047613.png)

But that's okay. Turns out building your own basic router isn't so hard.

Here's mine:

![Custom router code](./img/techletter.app-screenshot-1592236046783.png)

We use a `SCOPE_PAGE_MAP` that maps glob'd locations to their scopes. Use the `minimatch` library to find a matching path.

If path is found, render `<ScopedRoute>`, otherwise render `<Default>`.

The `SCOPE_PAGE_MAP` is a long list like this:

![Code example of a scope page map](./img/techletter.app-screenshot-1592236046982.png)

This part is tedious. Thinking of ways to move this info into MDX frontmatter that you can query with GraphQL.

Perhaps an idea for a Gatsby plugin ü§î

### 3. Default route

Now that you're mapping routes to components, you need those components :)

The `<Default>` component/route can be simple:

![Default route code](./img/techletter.app-screenshot-1592236046978.png)

Tells the layout that you're not authenticated, not authorized, and in my case to render the page fullwidth without the sidebar.

The `<Layout>` could check for this stuff with `useAuth` but it's cleaner to just tell it. _"Hey, show extra buttons for authorized users"_

### 4. scoped route

`<ScopedRoute>` is the bread and butter of this approach. And unlike my previous attempt, it's not gnarly at all ‚úåÔ∏è

![ScopedRoute code](./img/techletter.app-screenshot-1592236046808.png)

Hook into user state with `useAuth` and render different pages when they're authenticated, authorized, or unknown.

Flags in `<Layout>` change some UI features and the child element being `{element}` ‚Äì the MDX content ‚Äì or purchase/login specifies the core of the page.

And that's how you get elegant scope-based permissions in your JAMStack app ‚úåÔ∏è

Happy Monday

Cheers, ~Swizec

PS: scopes get into your users [the same way roles do](https://swizec.com/blog/add-granular-rolebased-access-to-your-jamstack-app/). You add them through the Auth0 API or UI and use a bit of Auth0 JavaScript to inject it into user properties on every request.
